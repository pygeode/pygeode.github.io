
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Other operations &#8212; PyGeode 1.4.1rc1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/pygtheme.css" />
    <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-rendered-html.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/pygeode_icon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Axis class overview" href="axes.html" />
    <link rel="prev" title="Array manipulation routines" href="varops.html" />
<link href="http://fonts.googleapis.com/css?family=Ubuntu:300,300italic,regular,italic,500,500italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700' rel='stylesheet' type='text/css'>

  </head><body>
      <div class="header" role="banner"><img class="logo" src="_static/pygeode_logo.png" width=79px alt="Logo"/>
        <h1 class="heading"><a href="index.html">
          <span>PyGeode 1.4.1rc1 documentation</span></a></h1>
        <h2 class="heading"><span>Other operations</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="varops.html">Array manipulation routines</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="reference.html">Reference</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="tutorial.html">Tutorial</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="gallery/index.html">Gallery</a>
        &#160;&#160;::&#160;&#160;
        <a href="axes.html">Axis class overview</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="other-operations">
<h1>Other operations<a class="headerlink" href="#other-operations" title="Permalink to this headline">¶</a></h1>
<dl class="py method">
<dt class="sig sig-object py" id="pygeode.Var.diff">
<span class="sig-prename descclassname"><span class="pre">Var.</span></span><span class="sig-name descname"><span class="pre">diff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygeode.Var.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the forward difference along the given axis.
Mimics the same behaviour of the <code class="xref py py-func docutils literal notranslate"><span class="pre">np.diff()</span></code> function.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>axis</strong><span class="classifier">string, <a class="reference internal" href="axes.html#pygeode.Axis" title="pygeode.Axis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Axis</span></code></a> class, or int</span></dt><dd><p>Axis along which to compute differences.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int (optional)</span></dt><dd><p>Number of times values are differenced.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>dvar</strong><span class="classifier"><a class="reference internal" href="var.html#pygeode.Var" title="pygeode.Var"><code class="xref py py-class docutils literal notranslate"><span class="pre">Var</span></code></a></span></dt><dd><p>New variable containing n-th differenced values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pygeode</span> <span class="k">as</span> <span class="nn">pyg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">pyg</span><span class="o">.</span><span class="n">yearlessn</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[:]</span>
<span class="go">array([0., 1., 2., 3., 4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)[:]</span>
<span class="go">array([1., 1., 1., 1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[:]</span>
<span class="go">array([0., 0., 0.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygeode.Var.deriv">
<span class="sig-prename descclassname"><span class="pre">Var.</span></span><span class="sig-name descname"><span class="pre">deriv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">daxis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'centre'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygeode.Var.deriv" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes derivative along the given axis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>daxis</strong><span class="classifier">string, <a class="reference internal" href="axes.html#pygeode.Axis" title="pygeode.Axis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Axis</span></code></a> class, or int</span></dt><dd><p>Axis along which to compute derivative.</p>
</dd>
<dt><strong>dx</strong><span class="classifier"><a class="reference internal" href="var.html#pygeode.Var" title="pygeode.Var"><code class="xref py py-class docutils literal notranslate"><span class="pre">Var</span></code></a>, or None (optional)</span></dt><dd><p>Coordinate with respect to which to take the derivative (see notes). Must
share axis along which the derivative is being taken. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
coordinate axis is used.</p>
</dd>
<dt><strong>df</strong><span class="classifier">string (optional)</span></dt><dd><p>Type of derivative to take. One of ‘left’, ‘right’, ‘centre’, or ‘2’. See
notes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>dvar</strong><span class="classifier"><a class="reference internal" href="var.html#pygeode.Var" title="pygeode.Var"><code class="xref py py-class docutils literal notranslate"><span class="pre">Var</span></code></a></span></dt><dd><p>Numerical derivative of <code class="docutils literal notranslate"><span class="pre">var</span></code></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The derivative is computed using a forward (df = ‘right’), backward (df =
‘left’), or centred (df = ‘centre’) difference approximation; for instance,
the forward difference is computed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dvar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">var</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span>
</pre></div>
</div>
<p>One-sided differences are used at the axis boundaries so that <code class="docutils literal notranslate"><span class="pre">dvar</span></code> is
defined on the same axis as <code class="docutils literal notranslate"><span class="pre">var</span></code>. The second derivative can also be
computed (df = ‘2’)</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pygeode</span> <span class="k">as</span> <span class="nn">pyg</span><span class="o">,</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pygeode.tutorial</span> <span class="kn">import</span> <span class="n">t1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">Temp</span><span class="o">.</span><span class="n">deriv</span><span class="p">(</span><span class="s1">&#39;lon&#39;</span><span class="p">))</span> <span class="c1"># Compute simple derivative</span>
<span class="go">&lt;Var &#39;dTemp&#39;&gt;:</span>
<span class="go">  Shape:  (lat,lon)  (31,60)</span>
<span class="go">  Axes:</span>
<span class="go">    lat &lt;Lat&gt;      :  90 S to 90 N (31 values)</span>
<span class="go">    lon &lt;Lon&gt;      :  0 E to 354 E (60 values)</span>
<span class="go">  Attributes:</span>
<span class="go">    {}</span>
<span class="go">  Type:  DerivativeVar (dtype=&quot;float64&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mf">6317e3</span> <span class="o">*</span> <span class="n">pyg</span><span class="o">.</span><span class="n">cosd</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.</span> <span class="o">*</span> <span class="n">t1</span><span class="o">.</span><span class="n">lon</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">Temp</span><span class="o">.</span><span class="n">deriv</span><span class="p">(</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="s1">&#39;2&#39;</span><span class="p">))</span> <span class="c1"># Compute 2nd derivative with respect to geometric length</span>
<span class="go">&lt;Var &#39;d2Temp&#39;&gt;:</span>
<span class="go">  Shape:  (lat,lon)  (31,60)</span>
<span class="go">  Axes:</span>
<span class="go">    lat &lt;Lat&gt;      :  90 S to 90 N (31 values)</span>
<span class="go">    lon &lt;Lon&gt;      :  0 E to 354 E (60 values)</span>
<span class="go">  Attributes:</span>
<span class="go">    {}</span>
<span class="go">  Type:  SecondDerivativeVar (dtype=&quot;float64&quot;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygeode.Var.integrate">
<span class="sig-prename descclassname"><span class="pre">Var.</span></span><span class="sig-name descname"><span class="pre">integrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iaxis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trapz'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygeode.Var.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes an indefinite integral along the given axis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>iaxis</strong><span class="classifier">string, <a class="reference internal" href="axes.html#pygeode.Axis" title="pygeode.Axis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Axis</span></code></a> class, or int</span></dt><dd><p>Axis along which to compute integral.</p>
</dd>
<dt><strong>dx</strong><span class="classifier"><a class="reference internal" href="var.html#pygeode.Var" title="pygeode.Var"><code class="xref py py-class docutils literal notranslate"><span class="pre">Var</span></code></a>, or None (optional)</span></dt><dd><p>Coordinate with respect to which to integrate (see notes). Must
share axis along which the derivative is being taken. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
coordinate axis is used.</p>
</dd>
<dt><strong>v0</strong><span class="classifier">float, <a class="reference internal" href="var.html#pygeode.Var" title="pygeode.Var"><code class="xref py py-class docutils literal notranslate"><span class="pre">Var</span></code></a>, or None (optional)</span></dt><dd><p>Constant of integration. See notes.</p>
</dd>
<dt><strong>order: int (1 or -1)</strong></dt><dd><p>Direction along axis to integrate. <code class="docutils literal notranslate"><span class="pre">1</span></code> corresponds to an integration from
the first to the last element, while <code class="docutils literal notranslate"><span class="pre">-1</span></code> integrates in the other
direction.</p>
</dd>
<dt><strong>type</strong><span class="classifier">string (optional)</span></dt><dd><p>Type of numerical integral to take. One of ‘trapz’, ‘rectr’, or ‘rectl’;
defaults to ‘trapz’. See notes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>ivar</strong><span class="classifier"><a class="reference internal" href="var.html#pygeode.Var" title="pygeode.Var"><code class="xref py py-class docutils literal notranslate"><span class="pre">Var</span></code></a></span></dt><dd><p>Numerical integral of <code class="docutils literal notranslate"><span class="pre">var</span></code></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Possible integration methods are</dt><dd><ul class="simple">
<li><p>‘trapz’: trapezoidal rule</p></li>
<li><p>‘rectl’: left rectangle method or Riemann sum</p></li>
<li><p>‘rectr’: right rectangle method or Riemann sum</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pygeode</span> <span class="k">as</span> <span class="nn">pyg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pygeode.tutorial</span> <span class="kn">import</span> <span class="n">t1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">Temp</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="s1">&#39;lon&#39;</span><span class="p">))</span> <span class="c1"># Compute simple derivative</span>
<span class="go">&lt;Var &#39;iTemp&#39;&gt;:</span>
<span class="go">  Shape:  (lat,lon)  (31,60)</span>
<span class="go">  Axes:</span>
<span class="go">    lat &lt;Lat&gt;      :  90 S to 90 N (31 values)</span>
<span class="go">    lon &lt;Lon&gt;      :  0 E to 354 E (60 values)</span>
<span class="go">  Attributes:</span>
<span class="go">    {}</span>
<span class="go">  Type:  IntegrateVar (dtype=&quot;float64&quot;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygeode.Var.interpolate">
<span class="sig-prename descclassname"><span class="pre">Var.</span></span><span class="sig-name descname"><span class="pre">interpolate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inaxis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outaxis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cspline'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_below</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_above</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transpose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omit_nonmonotonic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygeode.Var.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates a variable along a single dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>invar</strong><span class="classifier">Var</span></dt><dd><p>The input variable</p>
</dd>
<dt><strong>inaxis</strong><span class="classifier">Axis</span></dt><dd><p>The input axis being interpolated from</p>
</dd>
<dt><strong>outaxis</strong><span class="classifier">Axis</span></dt><dd><p>The output axis being interpolated to.</p>
</dd>
<dt><strong>inx</strong><span class="classifier">Var (optional)</span></dt><dd><p>The coordinates from which we are interpolating (must be conformable to the
input var). If not provided, the values of inaxis are used. This can be
either a one dimensional field defined on inaxis, or a multidimensional
field.</p>
</dd>
<dt><strong>outx</strong><span class="classifier">Var (optional)</span></dt><dd><p>The coordinates to which we are interpolating (must be conformable to the
output var).  If not provided, the values of outaxis are used. This can be
either a one dimensional field defined on outaxis, or a multidimensional
field.</p>
</dd>
<dt><strong>interp_type</strong><span class="classifier">string (optional)</span></dt><dd><p>The type of interpolation. One of ‘linear’, ‘polynomial’, ‘cspline’,
‘cspline_periodic’, ‘akima’, ‘akima_periodic’.
Default is ‘cspline’ (cubic spline interpolation)</p>
</dd>
<dt><strong>d_below</strong><span class="classifier">float (optional)</span></dt><dd><p>The slope for linearly extrapolating below the input data.</p>
</dd>
<dt><strong>d_above</strong><span class="classifier">float (optional)</span></dt><dd><p>The slope for linearly extrapolating above the input data.
By default, no extrapolation is done.</p>
</dd>
<dt><strong>transpose</strong><span class="classifier">boolean (optional)</span></dt><dd><p>If True, tranposes the output axes so that the axis to which we are interpolating
replaces the input axis in the axes order. Otherwise the new axis becomes the last
dimension.
Default is True.</p>
</dd>
<dt><strong>omit_nonmonotonic</strong><span class="classifier">boolean (optional)</span></dt><dd><p>If True, the interpolation routine skips over any non-monotonic datapoints
in the coordinate field from which we are interpolating. This is an experimental
feature; do not use unless you know what you are doing!
Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>interpolated</strong><span class="classifier">Var</span></dt><dd><p>The interpolated variable</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>if inx or outx are not explicitly given, they will take on the values of
inaxis and outaxis respectively.  Note that inx and outx are assumed to
have the same units, so if inaxis and outaxis have different units, you’ll
need to override either inx or outx explicitly, and provide some kind of
mapping field there.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1) Simple interpolation along one axis (re-gridding):

To interpolate some data to 20 evenly spaced longitude values (starting at 0):
newvar = Interp (invar = data, inaxis = &#39;lon&#39;, outaxis = Lon(20))

2) Interpolation involving a change of coordinates:

Suppose we have some ozone data (o3) on a model vertical coordinate.
Suppose we also have pre-computed a pressure field (pfield) over these coordinates.
Suppose finally we have our desired pressure axis (paxis) that we want to interpolate to.

To interpolate onto pressure levels:
newvar = Interp (invar = o3, inaxis = &#39;eta&#39;, outaxis = paxis, inx = pfield)
levels).

Now, you may be asking yourself &quot;shouldn&#39;t pressure be interpolated on a
log scale?&quot;.  This is true, but I tried to simplify things by assuming a
linear scale just to show the basics.  If you wanted to interpolate over
a log scale, then your interpolation coordinate would be log(pressure),
instead of pressure.  You&#39;ll have to explicitly provide this log coordinate
for both the inputs and outputs, for example:

newvar = Interp (invar = o3, inaxis = &#39;eta&#39;, outaxis = paxis,
                 inx = pfield.log(), outx = paxis.log()  )

Here, our input and output axes remain the same as before, but now we&#39;re
using log(pressure) internally as the coordinate over which to perform
the interpolation.
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygeode.Var.smooth">
<span class="sig-prename descclassname"><span class="pre">Var.</span></span><span class="sig-name descname"><span class="pre">smooth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">saxis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygeode.Var.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooths this variable along <code class="docutils literal notranslate"><span class="pre">saxis</span></code> by convolving it with an averaging
kernel. The returned variable is defined on the same axes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>saxis</strong><span class="classifier">any axis identifier (string, <a class="reference internal" href="axes.html#pygeode.Axis" title="pygeode.Axis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Axis</span></code></a>, or int)</span></dt><dd><p>Axis over which the smoothing should be performed</p>
</dd>
<dt><strong>kernel</strong><span class="classifier">sequence or int (optional)</span></dt><dd><p>Averaging kernel with which to convolve this variable. Does not need to
be normalized.  If an integer is provided, a Hanning window is used of
length <code class="docutils literal notranslate"><span class="pre">kernel</span></code> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hanning.html#numpy.hanning" title="(in NumPy v1.22)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.hanning()</span></code></a>)</p>
</dd>
<dt><strong>fft</strong><span class="classifier">boolean (optional, True by default)</span></dt><dd><p>If True, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/reference/generated/scipy.signal.fftconvolve.html#scipy.signal.fftconvolve" title="(in SciPy v1.7.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.fftconvolve()</span></code></a> is used to compute the convolution.
Otherwise, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/reference/generated/scipy.signal.convolve.html#scipy.signal.convolve" title="(in SciPy v1.7.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.convolve()</span></code></a> is used. In many cases the former
is more efficient.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier"><a class="reference internal" href="var.html#pygeode.Var" title="pygeode.Var"><code class="xref py py-class docutils literal notranslate"><span class="pre">Var</span></code></a></span></dt><dd><p>Smoothed variable.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When the convolution is performed, the source data is extended on either
end of the axis being smoothed by reflecting the data by enough to ensure
the returned variable is defined on the same grid as the source variable.
That is, if the original data is t1, t2, .., tN, and the kernel is L
items long, the convolved sequence is tj, t_j-1, t1, t1, t2, .. tN-1, tN,
tN, tN-1, .. tN-l, where j = floor(L/2) and l = L - j - 1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygeode.Var.fft_smooth">
<span class="sig-prename descclassname"><span class="pre">Var.</span></span><span class="sig-name descname"><span class="pre">fft_smooth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">saxis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxharm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygeode.Var.fft_smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooths this variable along <code class="docutils literal notranslate"><span class="pre">saxis</span></code> by retaining leading Fourier
components.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>saxis</strong><span class="classifier">any axis identifier (string, <a class="reference internal" href="axes.html#pygeode.Axis" title="pygeode.Axis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Axis</span></code></a>, or int)</span></dt><dd><p>Axis over which the smoothing should be performed</p>
</dd>
<dt><strong>maxharm</strong><span class="classifier">int</span></dt><dd><p>Maximum harmonic to retain.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier"><a class="reference internal" href="var.html#pygeode.Var" title="pygeode.Var"><code class="xref py py-class docutils literal notranslate"><span class="pre">Var</span></code></a></span></dt><dd><p>Smoothed variable.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The variable data is Fourier transformed using <code class="xref py py-func docutils literal notranslate"><span class="pre">np.fft.rfft()</span></code> (if real) or
<code class="xref py py-func docutils literal notranslate"><span class="pre">np.fft.fft()</span></code> (if complex). The coefficients for harmonics equal to and
greater than <code class="docutils literal notranslate"><span class="pre">maxharm</span></code> are set to zero, then an inverse transform is applied.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pygeode</span> <span class="k">as</span> <span class="nn">pyg</span><span class="o">,</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tm</span> <span class="o">=</span> <span class="n">pyg</span><span class="o">.</span><span class="n">modeltime365n</span><span class="p">(</span><span class="s1">&#39;1 Jan 2000&#39;</span><span class="p">,</span> <span class="mi">365</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">pyg</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">tm</span> <span class="o">/</span> <span class="mf">365.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">v</span><span class="p">[:])</span>
<span class="go">0.7071067811865476</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">fft_smooth</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)[:])</span> <span class="c1"># This retains only the annual and semi-annual cycle</span>
<span class="go">1.0983314772510289e-16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">fft_smooth</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)[:])</span> <span class="c1"># This retains up to the third harmonic</span>
<span class="go">0.7071067811865476</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygeode.Var.composite">
<span class="sig-prename descclassname"><span class="pre">Var.</span></span><span class="sig-name descname"><span class="pre">composite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygeode.Var.composite" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a composite based on this variable.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>&lt;axis selection&gt;</strong><span class="classifier">string</span></dt><dd><p>A single axis selection string (similar to <a class="reference internal" href="varops.html#pygeode.Var.__call__" title="pygeode.Var.__call__"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.__call__()</span></code></a>) that
specifies the central ‘date’ of each event to composite (although
composites need not be constructed along time axes). See Notes.</p>
</dd>
<dt><strong>evlen</strong><span class="classifier">int</span></dt><dd><p>Length of segement around each central ‘date’ to extract.</p>
</dd>
<dt><strong>evoff</strong><span class="classifier">int</span></dt><dd><p>Offset from the central ‘dates’ to include. A positive value
will lead to dates prior to the central ‘date’ being included.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>cvar</strong><span class="classifier"><a class="reference internal" href="var.html#pygeode.Var" title="pygeode.Var"><code class="xref py py-class docutils literal notranslate"><span class="pre">Var</span></code></a></span></dt><dd><p>Composite variable. The axis along which composites are to be constructed
is replaced by an Event axis and an Offset axis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The axis matched is used as the composite axis and the returned indices
are the key dates. evlen is required; it can either be an integer or a
list of integers specifying the length of each event. evoff is a single integer.
If the requested composite extends past the ends of the underlying axis, the
variable will contain NaNs.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pygeode</span> <span class="k">as</span> <span class="nn">pyg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pygeode.tutorial</span> <span class="kn">import</span> <span class="n">t2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dts</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;12 May 2012&#39;</span><span class="p">,</span> <span class="s1">&#39;15 Aug 2015&#39;</span><span class="p">,</span> <span class="s1">&#39;1 Feb 2018&#39;</span><span class="p">,</span> <span class="s1">&#39;28 Dec 2020&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cT</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">Temp</span><span class="o">.</span><span class="n">composite</span><span class="p">(</span><span class="n">l_time</span> <span class="o">=</span> <span class="n">dts</span><span class="p">,</span> <span class="n">evlen</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span> <span class="n">evoff</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cT</span><span class="p">)</span>
<span class="go">&lt;Var &#39;Temp&#39;&gt;:</span>
<span class="go">  Shape:  (event,time,pres,lat,lon)  (4,15,20,31,60)</span>
<span class="go">  Axes:</span>
<span class="go">    event &lt;Event&gt;  :  1  to 4  (4 values)</span>
<span class="go">    time &lt;Yearless&gt;:  day -10, 00:00:00 to day 4, 00:00:00 (15 values)</span>
<span class="go">    pres &lt;Pres&gt;    :  1000 hPa to 50 hPa (20 values)</span>
<span class="go">    lat &lt;Lat&gt;      :  90 S to 90 N (31 values)</span>
<span class="go">    lon &lt;Lon&gt;      :  0 E to 354 E (60 values)</span>
<span class="go">  Attributes:</span>
<span class="go">    {}</span>
<span class="go">  Type:  CompositeVar (dtype=&quot;float64&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cT</span><span class="p">(</span><span class="n">s_event</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s_pres</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">s_lat</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">s_lon</span> <span class="o">=</span> <span class="mi">180</span><span class="p">)[:]</span>
<span class="go">array([199.66766628, 199.69594407, 199.72479591, 199.75418884,</span>
<span class="go">       199.78408917, 199.81446257, 199.84527408, 199.87648814,</span>
<span class="go">       199.90806866, 199.939979  , 199.97218208, 200.00464036,</span>
<span class="go">       200.03731592, 200.07017048, 200.10316548])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cT</span><span class="p">(</span><span class="n">s_event</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">s_pres</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">s_lat</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">s_lon</span> <span class="o">=</span> <span class="mi">180</span><span class="p">)[:]</span>
<span class="go">array([201.02847025, 201.04367089, 201.05782423, 201.07091237,</span>
<span class="go">       201.08291874, 201.09382812, 201.10362669, 201.112302  ,</span>
<span class="go">       201.11984303, 201.12624021, 201.1314854 , 201.13557193,</span>
<span class="go">       201.1384946 , 201.14024969,          nan])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygeode.Var.flatten">
<span class="sig-prename descclassname"><span class="pre">Var.</span></span><span class="sig-name descname"><span class="pre">flatten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">naxis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygeode.Var.flatten" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygeode.Var.lag">
<span class="sig-prename descclassname"><span class="pre">Var.</span></span><span class="sig-name descname"><span class="pre">lag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iaxis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lags</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygeode.Var.lag" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a lag axis with offset values.</p>
</dd></dl>

<dl class="simple">
<dt><strong>See Also:</strong></dt><dd><p><a class="reference internal" href="var.html"><span class="doc">Var class overview</span></a></p>
</dd>
</dl>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="varops.html">Array manipulation routines</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="reference.html">Reference</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="tutorial.html">Tutorial</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="gallery/index.html">Gallery</a>
        &#160;&#160;::&#160;&#160;
        <a href="axes.html">Axis class overview</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Mike Neish, Peter Hitchcock.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
  </body>
</html>