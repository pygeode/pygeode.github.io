
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Basic Operations &#8212; PyGeode 1.4.0 documentation</title>
    <link rel="stylesheet" href="_static/pygtheme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/gallery.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Variable input and output" href="tut_io.html" />
    <link rel="prev" title="Getting Started" href="tut_gettingstarted.html" />
<link href="http://fonts.googleapis.com/css?family=Ubuntu:300,300italic,regular,italic,500,500italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700' rel='stylesheet' type='text/css'>

  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>PyGeode 1.4.0 documentation</span></a></h1>
        <h2 class="heading"><span>Basic Operations</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="tut_gettingstarted.html">Getting Started</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="reference.html">Reference</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="tutorial.html">Tutorial</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="gallery/index.html">Gallery</a>
        &#160;&#160;::&#160;&#160;
        <a href="tut_io.html">Variable input and output</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="basic-operations">
<h1>Basic Operations<a class="headerlink" href="#basic-operations" title="Permalink to this headline">¶</a></h1>
<p>Much of the functionality of PyGeode is found in the operations you can perform
on Var objects. We’ll start with the basics of slicing variables, then move on
to more complicated operations. An important thing to keep in mind, as
discussed in <a class="reference internal" href="tut_gettingstarted.html"><span class="doc">Getting Started</span></a>, is that these operations all delayed until
the data is specifically requested. For instance, one can compute an average
over longitude as follows:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">pyl</span><span class="p">;</span> <span class="n">pyl</span><span class="o">.</span><span class="n">ion</span><span class="p">();</span>

<span class="gp">In [2]: </span><span class="kn">import</span> <span class="nn">pygeode</span> <span class="k">as</span> <span class="nn">pyg</span>

<span class="gp">In [3]: </span><span class="kn">from</span> <span class="nn">pygeode.tutorial</span> <span class="kn">import</span> <span class="n">t1</span>

<span class="gp">In [4]: </span><span class="n">t_av</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">Temp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s1">&#39;lon&#39;</span><span class="p">)</span> <span class="c1"># Fast: no computations carried out</span>
</pre></div>
</div>
<p>However, while the variable <code class="docutils literal notranslate"><span class="pre">t_av</span></code> now represents this average (and one
can carry out further operations with it), no actual averaging has been done.
This only happens when the data itself is requested (either explicitly as a
numpy array as below, or when writing the data to disk, or plotting it):</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="nb">print</span><span class="p">(</span><span class="n">t_av</span><span class="p">[:])</span> <span class="c1"># Slower: data is loaded, and the averaging is carried out</span>
<span class="go">[260.73262556 261.22683172 261.98265134 263.09218962 264.65419211</span>
<span class="go"> 266.76053262 269.47711035 272.82122084 276.73945224 281.09169696</span>
<span class="go"> 285.64721554 290.09728624 294.08575156 297.25433608 299.29517258</span>
<span class="go"> 300.         299.29517258 297.25433608 294.08575156 290.09728624</span>
<span class="go"> 285.64721554 281.09169696 276.73945224 272.82122084 269.47711035</span>
<span class="go"> 266.76053262 264.65419211 263.09218962 261.98265134 261.22683172</span>
<span class="go"> 260.73262556]</span>
</pre></div>
</div>
<p>This should be kept in mind for the rest of the tutorial! We’ll get a bit lazy:
what line 4 in the code above really does is return a new PyGeode variable
that represents the mean over the longitude axis of the source variable, without
actually calculating the mean, but we’ll just say that we’ve computed the mean.
All of the operations in this section work this way - in fact, almost all of the
functions in PyGeode do, with a few exceptions that we’ll mention explicitly
when we get there.</p>
<div class="section" id="selecting-subsets">
<h2>Selecting subsets<a class="headerlink" href="#selecting-subsets" title="Permalink to this headline">¶</a></h2>
<p>Reference: <a class="reference internal" href="varops.html#pygeode.Var.__call__" title="pygeode.Var.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Var.__call__()</span></code></a></p>
<p>One of the most basic operations is to select a subset or subdomain of your
variable. For instance, to select a rectangular region of the same temperature
variable we just saw:</p>
<pre class="literal-block">
In [6]: print(t1.Temp(lat=(30, 50), lon=(100, 180)))
&lt;Var 'Temp'&gt;:
  Units: K  Shape:  (lat,lon)  (4,14)
  Axes:
    lat &lt;Lat&gt;      :  30 N to 48 N (4 values)
    lon &lt;Lon&gt;      :  102 E to 180 E (14 values)
  Attributes:
    {}
  Type:  SlicedVar (dtype=&quot;float64&quot;)

# We can take a look at the latitude grid points for reference
In [7]: t1.Temp.lat[:]
Out[7]: 
array([-90., -84., -78., -72., -66., -60., -54., -48., -42., -36., -30.,
       -24., -18., -12.,  -6.,   0.,   6.,  12.,  18.,  24.,  30.,  36.,
        42.,  48.,  54.,  60.,  66.,  72.,  78.,  84.,  90.])
</pre>
<p>PyGeode makes use of the calling syntax of Python to do slicing. While this is
arguably an abuse of the syntax, this operation is so common that it’s a
default behaviour for PyGeode variables. The axes are specified as keyword
arguments, and ranges are given as a tuple in coordinate space (as opposed to
the indices). Not all axes need be specified: any axes not mentioned are left
alone. Note that the subset includes elements lying on and within the
boundaries of the range requested (30 N to 50 N in this case). To demonstrate
this we’ve printed out the grid points of the latitude axis in line 6; so one
can see that this call returns a subset from latitude 30 N (on the boundary of
the range requested) to 48 N, since the next grid point is at 54 N.</p>
<p>You can also request a single element. The returned variable will always have
the same number of dimensions as the source variable (in the same order, though
not necessarily the same length), even if some of them are of length 1.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [8]: </span><span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">Temp</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="mi">12</span><span class="p">))</span>
<span class="go">&lt;Var &#39;Temp&#39;&gt;:</span>
<span class="go">  Units: K  Shape:  (lat,lon)  (1,60)</span>
<span class="go">  Axes:</span>
<span class="go">    lat &lt;Lat&gt;      :  12 N</span>
<span class="go">    lon &lt;Lon&gt;      :  0 E to 354 E (60 values)</span>
<span class="go">  Attributes:</span>
<span class="go">    {}</span>
<span class="go">  Type:  SlicedVar (dtype=&quot;float64&quot;)</span>
</pre></div>
</div>
<p>If the (zero-based) index is more convenient, you can specify this by prefixing
the axis name with <code class="docutils literal notranslate"><span class="pre">i_</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [9]: </span><span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">Temp</span><span class="p">(</span><span class="n">i_lat</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
<span class="go">lat &lt;Lat&gt;      :  60 S</span>
</pre></div>
</div>
<p>Negative values index the axes in reverse, as in Python:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [10]: </span><span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">Temp</span><span class="p">(</span><span class="n">i_lat</span><span class="o">=-</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
<span class="go">lat &lt;Lat&gt;      :  66 N</span>
</pre></div>
</div>
<p>Another useful prefix is <code class="docutils literal notranslate"><span class="pre">l_</span></code>, which lets you select an arbitrary set of
points:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [11]: </span><span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">Temp</span><span class="p">(</span><span class="n">l_lat</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">25</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">92</span><span class="p">))</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
<span class="go">[-24.   0.  60.  90.]</span>
</pre></div>
</div>
<p>You’ll notice that if the requested value lies between two grid points in the
subsetted axis (<code class="docutils literal notranslate"><span class="pre">lat</span></code> in this case), the closer of the two will be returned.
This is also the case for values lying outside the range of the axis - this can
lead to some surprises if the axes has a different range than you expect. This
‘nearest match’ behaviour only holds for floating-point valued axes -
integer-valued axes (such as those that might index members of an ensemble, for
instance) only return exact matches.</p>
<p>The subsetted axis will always retain the order of the source axis, regardless
of what order you give the list. There are some other useful shortcuts here, but
we’ll introduce them a bit later on. In most cases, these prefix shortcuts can
be combined, so that <code class="docutils literal notranslate"><span class="pre">li_</span></code> can be used to select a list based on indices of
the subsetted axes instead of values.</p>
<p>Time axes are a bit of special case. PyGeode has a reasonably sophisticated
time axis, which is aware of four types of calendars - the standard Gregorian
calendar (<a class="reference internal" href="timeaxes.html#pygeode.StandardTime" title="pygeode.StandardTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">StandardTime</span></code></a>), a 365-day calendar (<a class="reference internal" href="timeaxes.html#pygeode.ModelTime365" title="pygeode.ModelTime365"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModelTime365</span></code></a>), a
360-day calendar (<a class="reference internal" href="timeaxes.html#pygeode.ModelTime360" title="pygeode.ModelTime360"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModelTime360</span></code></a>), and a yearless calendar
(<a class="reference internal" href="timeaxes.html#pygeode.Yearless" title="pygeode.Yearless"><code class="xref py py-class docutils literal notranslate"><span class="pre">Yearless</span></code></a>), which might better be described as a time axis with no
calendar at all. The example data set <code class="docutils literal notranslate"><span class="pre">t2</span></code>, for instance, is defined on a
365-day calendar. These are represented internally as a list of offsets (in
this case in days) from a reference date:</p>
<pre class="literal-block">
In [12]: from pygeode.tutorial import t2

In [13]: print(t2.time.startdate)
{'year': 2011, 'month': 1, 'day': 1, 'hour': 0, 'minute': 0, 'second': 0}

In [14]: print(t2.time.values)
[0.000e+00 1.000e+00 2.000e+00 ... 3.647e+03 3.648e+03 3.649e+03]
</pre>
<p>Time axes can be subsetted exactly as above, in which case the requested value
is matched against this offset:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [15]: </span><span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">Temp</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
<span class="go">time &lt;ModelTime365&gt;:  Jan 9, 2011 00:00:00</span>
</pre></div>
</div>
<p>However, these can be difficult to use directly, and can easily correspond to
very different dates if two time axes have different reference dates. Other
possibilities exist:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># Select a range of dates, from 12 December 2013 to 18 January 2014</span>
<span class="gp">In [16]: </span><span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">Temp</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;12 Dec 2013&#39;</span><span class="p">,</span> <span class="s1">&#39;18 Jan 2014&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
<span class="go">time &lt;ModelTime365&gt;:  Dec 12, 2013 00:00:00 to Jan 18, 2014 00:00:00 (38 values)</span>
</pre></div>
</div>
<p>PyGeode also recognizes the format <code class="docutils literal notranslate"><span class="pre">16:00</span> <span class="pre">13</span> <span class="pre">May</span> <span class="pre">1982</span></code> if a more precise
specification is required.</p>
<pre class="literal-block">
# Select all elements in year 2013
In [17]: print(t2.Temp(year = 2013).time)
time &lt;ModelTime365&gt;:  Jan 1, 2013 00:00:00 to Dec 31, 2013 00:00:00 (365 values)

# Select all elements in any January, February or December
In [18]: print(t2.Temp(l_month = (1, 2, 12)).time)
time &lt;ModelTime365&gt;:  Jan 1, 2011 00:00:00 to Dec 31, 2020 00:00:00 (900 values)
</pre>
<p>These last two are particularly useful constructs; you will have noticed that
axes need not be regularly spaced. Note that <code class="docutils literal notranslate"><span class="pre">year</span></code> and <code class="docutils literal notranslate"><span class="pre">month</span></code> here are
not axes of <code class="docutils literal notranslate"><span class="pre">t2.Temp</span></code> – they are technically ‘auxilliary arrays’ of the time
axis; this detail doesn’t much matter for users, except that while in most
cases they behave exactly as if they were an axis for the purpose of subsetting
variables, not all prefixes work. In particular the prefix <code class="docutils literal notranslate"><span class="pre">i_</span></code> is not
recognized.  <code class="docutils literal notranslate"><span class="pre">day</span></code>, <code class="docutils literal notranslate"><span class="pre">hour</span></code>, <code class="docutils literal notranslate"><span class="pre">minute</span></code>, and <code class="docutils literal notranslate"><span class="pre">second</span></code> work in the same
way. More details about time axes can be found here <a class="reference internal" href="tut_axes.html#timeaxisops"><span class="std std-ref">Time Axis Operations</span></a>.</p>
<p>These examples all return a new PyGeode variable, as explained at the beginning
of the section. If you ever do just need the raw numerical data (in the form of
a numpy array), you can use standard slicing notation on a pygeode variable
(<code class="docutils literal notranslate"><span class="pre">t1.Temp[:]</span></code> will return everything). Note that, unlike keyword-based subsetting,
but like the behaviour expected with selecting out of numpy arrays, degenerate
axes are removed in this unlike numpy slicing, degenerate axes are removed.
That is, <code class="docutils literal notranslate"><span class="pre">t1.Temp[0,</span> <span class="pre">1]</span></code> returns a scalar, while <code class="docutils literal notranslate"><span class="pre">t1.Temp(i_lat=0,</span> <span class="pre">i_lon=1)</span></code>
returns a two dimensional variable.</p>
</div>
<div class="section" id="arithmetic-operations-and-broadcasting-rules">
<h2>Arithmetic operations and broadcasting rules<a class="headerlink" href="#arithmetic-operations-and-broadcasting-rules" title="Permalink to this headline">¶</a></h2>
<p>Reference: <a class="reference internal" href="ufunc.html"><span class="doc">Element-wise math</span></a> and <a class="reference internal" href="var.arith.html"><span class="doc">Arithmetic Operations on Variables</span></a></p>
<p>Arithmetic and other mathematical operations are also supported by PyGeode. The
simplest are unary operations, which are performed elementwise. Most standard
mathematical functions (powers, exponentials, trigonometric functions, etc.)
are supported, and can be found in the main <code class="docutils literal notranslate"><span class="pre">pygeode</span></code> module:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [19]: </span><span class="n">pyg</span><span class="o">.</span><span class="n">showvar</span><span class="p">(</span><span class="n">pyg</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">Temp</span><span class="p">))</span>     <span class="c1"># Plot the natural logarithm of Temp</span>
<span class="gh">Out[19]: </span><span class="go">&lt;pygeode.plot.wrappers.AxesWrapper at 0x7f28989dc080&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/log_t1Temp.png"><img alt="_images/log_t1Temp.png" src="_images/log_t1Temp.png" style="width: 4in;" /></a>
<p>There are some convenience functions included, for instance, most trig functions
have a version which takes arguments in degrees rather than radians:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [20]: </span><span class="n">pyg</span><span class="o">.</span><span class="n">showvar</span><span class="p">(</span><span class="n">pyg</span><span class="o">.</span><span class="n">sind</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">lat</span><span class="p">))</span>     <span class="c1"># Compute the sine of latitude</span>
<span class="gh">Out[20]: </span><span class="go">&lt;pygeode.plot.wrappers.AxesWrapper at 0x7f2896573f28&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/sind_t1lat.png"><img alt="_images/sind_t1lat.png" src="_images/sind_t1lat.png" style="width: 4in;" /></a>
<p>In most cases the underlying operation is performed by the numpy equivalent,
though there are a few additional operations as well. A full list can be found
in <a class="reference internal" href="ufunc.html"><span class="doc">Element-wise math</span></a>. The PyGeode wrappers are designed to properly handle PyGeode
variables, so one should get accustomed to including the <code class="docutils literal notranslate"><span class="pre">pyg</span></code> prefix. This
is also a good reason to import pygeode into its own namespace, rather than
into the top-level namespace itself.</p>
<p>Standard Python binary arithmetic operations (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>,
<code class="docutils literal notranslate"><span class="pre">**</span></code>, etc.) are supported and work as one would expect if all the
variables are defined on the same axes. Comparison operators (<code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, etc.)
are also supported and produce a boolean variable on the same axes with the result of
the operation performed elementwise. This can be very useful for masking data,
since when cast to scalar values, <code class="docutils literal notranslate"><span class="pre">True</span></code> is equal to 1 and <code class="docutils literal notranslate"><span class="pre">False</span></code> is equal to 0:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [21]: </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="gp">In [22]: </span><span class="n">pyg</span><span class="o">.</span><span class="n">showvar</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">Temp</span> <span class="o">&gt;</span> <span class="mf">280.</span><span class="p">,</span> <span class="n">clevs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.11</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>
<span class="gh">Out[22]: </span><span class="go">&lt;pygeode.plot.wrappers.AxesWrapper at 0x7f28964bc5f8&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/t1mask.png"><img alt="_images/t1mask.png" src="_images/t1mask.png" style="width: 4in;" /></a>
<p>If the variables do not share the same axes, PyGeode follows a set of rules for
automatically broadcasting them so that the operations behave as one might
typically desire - it’s important to be aware of these rules as you can
sometimes end up with some unexpected results, so they are described here in
some detail.</p>
<div class="section" id="broadcasting">
<span id="id1"></span><h3>Broadcasting<a class="headerlink" href="#broadcasting" title="Permalink to this headline">¶</a></h3>
<p>When performing a binary operation, PyGeode will broadcast each variable along
the dimensions of the other which it does not itself possess. The order of the
axes in the resulting variable is given by the first variable’s axes, followed
by those of the second which are not included in the first.</p>
<p>A couple of examples will clarify this:</p>
<pre class="literal-block">
In [23]: print((t2.U + t2.Temp).axes)   # No broadcasting required
(&lt;ModelTime365&gt;, &lt;Pres&gt;, &lt;Lat&gt;, &lt;Lon&gt;)

In [24]: print((t2.lat + t2.lon).axes)  # Broadcast to (lat, lon)
(&lt;Lat&gt;, &lt;Lon&gt;)

In [25]: print((t2.lon + t2.lat).axes)  # Broadcast to (lon, lat)
(&lt;Lon&gt;, &lt;Lat&gt;)
</pre>
<p>The one exception to this rule is that if either variable is defined on a subset
of the other’s axes, the order of the latter is maintained:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [26]: </span><span class="nb">print</span><span class="p">((</span><span class="n">t2</span><span class="o">.</span><span class="n">lon</span> <span class="o">+</span> <span class="n">t2</span><span class="o">.</span><span class="n">Temp</span><span class="p">)</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>  <span class="c1"># Broadcast to (time, pres, lat, lon)</span>
<span class="go">(&lt;ModelTime365&gt;, &lt;Pres&gt;, &lt;Lat&gt;, &lt;Lon&gt;)</span>
</pre></div>
</div>
<p>You may be wondering how PyGeode decides whether two axes are the same for the
purposes of this broadcasting. If two axes have the same elements (to within a
tolerance - see <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.allclose.html#numpy.allclose" title="(in NumPy v1.18)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.allclose()</span></code></a>), and are of the same type, they are
considered equal (see also <code class="xref py py-func docutils literal notranslate"><span class="pre">Axis:__eq__()</span></code>) and are matched. If PyGeode finds
two axes of the same type but with different elements, it attempts to find a complete
mapping from one to the other. In most cases this means that the elements of one
axis must be a subset of the other, and the broadcasted variable acquires the
smaller of the two axes; e.g. in the following case, PyGeode uses the smaller
of the two longitude axes, since it is a subset of the longitude axis of
<code class="docutils literal notranslate"><span class="pre">t2.Temp</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># Broadcasting restricts longitude axis to subset</span>
<span class="gp">In [27]: </span><span class="nb">print</span><span class="p">((</span><span class="n">t2</span><span class="o">.</span><span class="n">Temp</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">180</span><span class="p">))</span> <span class="o">-</span> <span class="n">t2</span><span class="o">.</span><span class="n">Temp</span><span class="p">)</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
<span class="go">lon &lt;Lon&gt;      :  0 E to 180 E (31 values)</span>
</pre></div>
</div>
<p>However, if pygeode finds two axes that could be compatible, but whose elements can
not be simply mapped to one another, PyGeode will raise an exception:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># Subsetted longitude axes are not compatible:</span>
<span class="gp">In [28]: </span><span class="k">try</span><span class="p">:</span> <span class="nb">print</span><span class="p">((</span><span class="n">t2</span><span class="o">.</span><span class="n">Temp</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">180</span><span class="p">))</span> <span class="o">+</span> <span class="n">t2</span><span class="o">.</span><span class="n">Temp</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="p">(</span><span class="mi">120</span><span class="p">,</span> <span class="mi">240</span><span class="p">)))</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
<span class="gp">   ....: </span><span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="gp">   ....: </span>
<span class="go">Axes &lt;lon &lt;Lon&gt;      :  120 E to 240 E (21 values)&gt; and &lt;lon &lt;Lon&gt;      :  0 E to 180 E (31 values)&gt; cannot be mapped.</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="reductions-averages-standard-deviations">
<h2>Reductions (Averages, Standard deviations)<a class="headerlink" href="#reductions-averages-standard-deviations" title="Permalink to this headline">¶</a></h2>
<p>As we saw at the beginning of this section, you can compute averages over a
variable with <a class="reference internal" href="reduce.html#pygeode.Var.mean" title="pygeode.Var.mean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mean()</span></code></a>. By default this computes an average over the
whole domain, but you can specify particular axes you want to average over. For
example,</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [29]: </span><span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">Temp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s1">&#39;pres&#39;</span><span class="p">,</span> <span class="n">pyg</span><span class="o">.</span><span class="n">Lon</span><span class="p">))</span>
<span class="go">&lt;Var &#39;Temp&#39;&gt;:</span>
<span class="go">  Shape:  (time,lat)  (3650,31)</span>
<span class="go">  Axes:</span>
<span class="go">    time &lt;ModelTime365&gt;:  Jan 1, 2011 00:00:00 to Dec 31, 2020 00:00:00 (3650 values)</span>
<span class="go">    lat &lt;Lat&gt;      :  90 S to 90 N (31 values)</span>
<span class="go">  Attributes:</span>
<span class="go">    {}</span>
<span class="go">  Type:  MeanVar (dtype=&quot;float64&quot;)</span>
</pre></div>
</div>
<p>This computes an average over the both the pressure and longitude axes. You can
specify axes in three ways:</p>
<blockquote>
<div><ul class="simple">
<li>by name, e.g. <code class="docutils literal notranslate"><span class="pre">t2.Temp.mean('lon')</span></code></li>
<li>by class, e.g. <code class="docutils literal notranslate"><span class="pre">t2.Temp.mean(pyg.Lon)</span></code></li>
<li>or by (zero-based) index, e.g. <code class="docutils literal notranslate"><span class="pre">t2.Temp.mean(3)</span></code></li>
</ul>
</div></blockquote>
<p>These will all (in this case) return the same average. These three ways of
identifying axes are pretty general across PyGeode routines.</p>
<p>Often it’s useful to compute an average over a subset of the domain. You could
first select the subdomain, then compute the mean (<code class="docutils literal notranslate"><span class="pre">t2.Temp(lat=(70,</span>
<span class="pre">90)).mean('lat')</span></code>), but this is such a common operation that there is a short
cut in the form of another selection prefix, <code class="docutils literal notranslate"><span class="pre">m_</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [30]: </span><span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">Temp</span><span class="p">(</span><span class="n">m_lat</span><span class="o">=</span><span class="p">(</span><span class="mi">70</span><span class="p">,</span> <span class="mi">90</span><span class="p">)))</span>
<span class="go">&lt;Var &#39;Temp&#39;&gt;:</span>
<span class="go">  Shape:  (time,pres,lon)  (3650,20,60)</span>
<span class="go">  Axes:</span>
<span class="go">    time &lt;ModelTime365&gt;:  Jan 1, 2011 00:00:00 to Dec 31, 2020 00:00:00 (3650 values)</span>
<span class="go">    pres &lt;Pres&gt;    :  1000 hPa to 50 hPa (20 values)</span>
<span class="go">    lon &lt;Lon&gt;      :  0 E to 354 E (60 values)</span>
<span class="go">  Attributes:</span>
<span class="go">    {}</span>
<span class="go">  Type:  WeightedMeanVar (dtype=&quot;float64&quot;)</span>
</pre></div>
</div>
<p>This selects all latitudes between 70 N and 90 N and performs an average.</p>
<p>You may notice this last operation returned a <code class="docutils literal notranslate"><span class="pre">WeightedMeanVar</span></code>, rather than just a <code class="docutils literal notranslate"><span class="pre">MeanVar</span></code>.
PyGeode, by default, will perform weighted averages over axes which have weights associated with
them. In this case, our latitude axis is weighted its cosine, to take in to account the smaller
surface area near the poles:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [31]: </span><span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">Temp</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
<span class="go">[6.12323400e-17 1.04528463e-01 2.07911691e-01 3.09016994e-01</span>
<span class="go"> 4.06736643e-01 5.00000000e-01 5.87785252e-01 6.69130606e-01</span>
<span class="go"> 7.43144825e-01 8.09016994e-01 8.66025404e-01 9.13545458e-01</span>
<span class="go"> 9.51056516e-01 9.78147601e-01 9.94521895e-01 1.00000000e+00</span>
<span class="go"> 9.94521895e-01 9.78147601e-01 9.51056516e-01 9.13545458e-01</span>
<span class="go"> 8.66025404e-01 8.09016994e-01 7.43144825e-01 6.69130606e-01</span>
<span class="go"> 5.87785252e-01 5.00000000e-01 4.06736643e-01 3.09016994e-01</span>
<span class="go"> 2.07911691e-01 1.04528463e-01 6.12323400e-17]</span>
</pre></div>
</div>
<p>You can turn this off, if desired, by specifying <code class="docutils literal notranslate"><span class="pre">weights=False</span></code> as a keyword argument:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [32]: </span><span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">Temp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">&lt;Var &#39;Temp&#39;&gt;:</span>
<span class="go">  Shape:  (time,pres,lon)  (3650,20,60)</span>
<span class="go">  Axes:</span>
<span class="go">    time &lt;ModelTime365&gt;:  Jan 1, 2011 00:00:00 to Dec 31, 2020 00:00:00 (3650 values)</span>
<span class="go">    pres &lt;Pres&gt;    :  1000 hPa to 50 hPa (20 values)</span>
<span class="go">    lon &lt;Lon&gt;      :  0 E to 354 E (60 values)</span>
<span class="go">  Attributes:</span>
<span class="go">    {}</span>
<span class="go">  Type:  MeanVar (dtype=&quot;float64&quot;)</span>
</pre></div>
</div>
<p>Alternatively, you can specify your own weights to use, in the form of a PyGeode
variable with the same axes as those you would like to weight:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [33]: </span><span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">Temp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">pyg</span><span class="o">.</span><span class="n">sind</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">Temp</span><span class="o">.</span><span class="n">lat</span><span class="p">)))</span>
<span class="go">&lt;Var &#39;Temp&#39;&gt;:</span>
<span class="go">  Shape:  (time,pres,lon)  (3650,20,60)</span>
<span class="go">  Axes:</span>
<span class="go">    time &lt;ModelTime365&gt;:  Jan 1, 2011 00:00:00 to Dec 31, 2020 00:00:00 (3650 values)</span>
<span class="go">    pres &lt;Pres&gt;    :  1000 hPa to 50 hPa (20 values)</span>
<span class="go">    lon &lt;Lon&gt;      :  0 E to 354 E (60 values)</span>
<span class="go">  Attributes:</span>
<span class="go">    {}</span>
<span class="go">  Type:  WeightedMeanVar (dtype=&quot;float64&quot;)</span>
</pre></div>
</div>
<p>The weights do not need to be normalized; PyGeode will do that automatically.</p>
<p>There are several other axes reductions that behave similarly, including
<a class="reference internal" href="reduce.html#pygeode.Var.stdev" title="pygeode.Var.stdev"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.stdev()</span></code></a>, <a class="reference internal" href="reduce.html#pygeode.Var.variance" title="pygeode.Var.variance"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.variance()</span></code></a>, <a class="reference internal" href="reduce.html#pygeode.Var.sum" title="pygeode.Var.sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.sum()</span></code></a>,
<a class="reference internal" href="reduce.html#pygeode.Var.min" title="pygeode.Var.min"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.min()</span></code></a>, <a class="reference internal" href="reduce.html#pygeode.Var.max" title="pygeode.Var.max"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.max()</span></code></a>; see <a class="reference internal" href="var.html#reduce-list"><span class="std std-ref">Axis Reductions</span></a>
for the full list.  Some differences exist though:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="reduce.html#pygeode.Var.sum" title="pygeode.Var.sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.sum()</span></code></a> by default does <em>not</em> use the axes weights; you can use the
default weights by specifying <code class="docutils literal notranslate"><span class="pre">weights=True</span></code> as a keyword argument.</li>
<li><a class="reference internal" href="reduce.html#pygeode.Var.max" title="pygeode.Var.max"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.max()</span></code></a> and  <a class="reference internal" href="reduce.html#pygeode.Var.min" title="pygeode.Var.min"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.min()</span></code></a> do not use weights; they return the maximum and
minimum values (respectively) along the axes being reduced.</li>
</ul>
</div></blockquote>
<p>Finally, there are also equivalents for several of these methods which are <code class="docutils literal notranslate"><span class="pre">NaN</span></code> aware.</p>
</div>
<div class="section" id="reshaping-variables">
<h2>Reshaping variables<a class="headerlink" href="#reshaping-variables" title="Permalink to this headline">¶</a></h2>
<p>Finally, there are a whole set of basic manipulations you can perform on variables if you need to
rework their structure. Some of the most common are introduced here; for a complete list see
<a class="reference internal" href="var.html#varops-list"><span class="std std-ref">Array manipulation routines</span></a>. Keep in mind that variables are thought of as immutable objects - that is, once
they’re created, they don’t change - as before, what the following operations actually do is return
a new variable with the desired changes that wraps the old one.</p>
<p><a class="reference internal" href="varops.html#pygeode.Var.transpose" title="pygeode.Var.transpose"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.transpose()</span></code></a> reorders the axes of a variable. Not all axes need to
be specified; those that are not will be appended in their present order.</p>
<pre class="literal-block">
In [34]: t2.Temp.axes
Out[34]: (&lt;ModelTime365&gt;, &lt;Pres&gt;, &lt;Lat&gt;, &lt;Lon&gt;)

In [35]: print(t2.Temp.transpose('lon', 'lat', 'pres', 'time').axes)
(&lt;Lon&gt;, &lt;Lat&gt;, &lt;Pres&gt;, &lt;ModelTime365&gt;)
</pre>
<p><a class="reference internal" href="varops.html#pygeode.Var.replace_axes" title="pygeode.Var.replace_axes"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.replace_axes()</span></code></a> replaces any or all axes of a variable. The new
axes must have the same length as those they are replacing.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># The logPAxis method returns a log-pressure axis with a given scale height</span>
<span class="gp">In [36]: </span><span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">Temp</span><span class="o">.</span><span class="n">replace_axes</span><span class="p">(</span><span class="n">pres</span><span class="o">=</span><span class="n">t2</span><span class="o">.</span><span class="n">pres</span><span class="o">.</span><span class="n">logPAxis</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="mi">7000</span><span class="p">))</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
<span class="go">(&lt;ModelTime365&gt;, &lt;ZAxis&gt;, &lt;Lat&gt;, &lt;Lon&gt;)</span>
</pre></div>
</div>
<p><a class="reference internal" href="varops.html#pygeode.Var.squeeze" title="pygeode.Var.squeeze"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.squeeze()</span></code></a> removes degenerate axes (those with one or fewer elements).
As mentioned above, the default selection behaviour is to always return a
variable with the same number of axes as you’ve started with, even if those
axes have only a single element. If you want to remove these degenerate axes,
you can use this command, which, when called with no arguments, will simply remove
all degenerate axes. Several other methods of calling are also available:</p>
<pre class="literal-block">
# Squeeze all degenerate axes
In [37]: print(t2.Temp(time = 4, lon = 20).squeeze())
&lt;Var 'Temp'&gt;:
  Shape:  (pres,lat)  (20,31)
  Axes:
    pres &lt;Pres&gt;    :  1000 hPa to 50 hPa (20 values)
    lat &lt;Lat&gt;      :  90 S to 90 N (31 values)
  Attributes:
    {}
  Type:  SqueezedVar (dtype=&quot;float64&quot;)

# Squeeze only the time axis (if it is degenerate)
In [38]: print(t2.Temp(time = 4, lon = 20).squeeze('time'))
&lt;Var 'Temp'&gt;:
  Shape:  (pres,lat,lon)  (20,31,1)
  Axes:
    pres &lt;Pres&gt;    :  1000 hPa to 50 hPa (20 values)
    lat &lt;Lat&gt;      :  90 S to 90 N (31 values)
    lon &lt;Lon&gt;      :  18 E
  Attributes:
    {}
  Type:  SqueezedVar (dtype=&quot;float64&quot;)

# Select a single value then squeeze the time axis
In [39]: print(t2.Temp.squeeze(time = 4))
&lt;Var 'Temp'&gt;:
  Shape:  (pres,lat,lon)  (20,31,60)
  Axes:
    pres &lt;Pres&gt;    :  1000 hPa to 50 hPa (20 values)
    lat &lt;Lat&gt;      :  90 S to 90 N (31 values)
    lon &lt;Lon&gt;      :  0 E to 354 E (60 values)
  Attributes:
    {}
  Type:  SqueezedVar (dtype=&quot;float64&quot;)

# Select a single value and sqeeze the time axis using a selection prefix
In [40]: print(t2.Temp(s_time = 4, lon = (20, 40)))
&lt;Var 'Temp'&gt;:
  Shape:  (pres,lat,lon)  (20,31,3)
  Axes:
    pres &lt;Pres&gt;    :  1000 hPa to 50 hPa (20 values)
    lat &lt;Lat&gt;      :  90 S to 90 N (31 values)
    lon &lt;Lon&gt;      :  24 E to 36 E (3 values)
  Attributes:
    {}
  Type:  SqueezedVar (dtype=&quot;float64&quot;)
</pre>
<p>There are also commands to rename variables and their axes
(<a class="reference internal" href="varops.html#pygeode.Var.rename" title="pygeode.Var.rename"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.rename()</span></code></a>, <a class="reference internal" href="varops.html#pygeode.Var.rename_axes" title="pygeode.Var.rename_axes"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.rename_axes()</span></code></a>), for adding axes to a
variable (<a class="reference internal" href="varops.html#pygeode.Var.extend" title="pygeode.Var.extend"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.extend()</span></code></a>), reordering axes elements
(<a class="reference internal" href="varops.html#pygeode.Var.sorted" title="pygeode.Var.sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.sorted()</span></code></a>) and dealing with NaNs (<a class="reference internal" href="varops.html#pygeode.Var.fill" title="pygeode.Var.fill"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.fill()</span></code></a>,
<a class="reference internal" href="varops.html#pygeode.Var.unfill" title="pygeode.Var.unfill"><code class="xref py py-func docutils literal notranslate"><span class="pre">Var.unfill()</span></code></a>).</p>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="tut_gettingstarted.html">Getting Started</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="reference.html">Reference</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="tutorial.html">Tutorial</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="gallery/index.html">Gallery</a>
        &#160;&#160;::&#160;&#160;
        <a href="tut_io.html">Variable input and output</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Mike Neish, Peter Hitchcock.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>