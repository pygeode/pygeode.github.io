
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pygeode.formats &#8212; PyGeode 1.4.0 documentation</title>
    <link rel="stylesheet" href="../../_static/pygtheme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<link href="http://fonts.googleapis.com/css?family=Ubuntu:300,300italic,regular,italic,500,500italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700' rel='stylesheet' type='text/css'>

  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>PyGeode 1.4.0 documentation</span></a></h1>
        <h2 class="heading"><span>pygeode.formats</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="../../reference.html">Reference</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../tutorial.html">Tutorial</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../gallery/index.html">Gallery</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for pygeode.formats</h1><div class="highlight"><pre>
<span></span>
<span class="c1"># Include &quot;pygeode.formats&quot; from other PyGeode-based packages.</span>
<span class="kn">from</span> <span class="nn">pkgutil</span> <span class="kn">import</span> <span class="n">extend_path</span>
<span class="n">__path__</span> <span class="o">=</span> <span class="n">extend_path</span><span class="p">(</span><span class="n">__path__</span><span class="p">,</span> <span class="vm">__name__</span><span class="p">)</span>
<span class="k">del</span> <span class="n">extend_path</span>

<span class="c1"># Include packages via the entry_points mechanism of pkg_resources.</span>
<span class="kn">import</span> <span class="nn">pkg_resources</span>
<span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">iter_entry_points</span><span class="p">(</span><span class="s1">&#39;pygeode.formats&#39;</span><span class="p">):</span>
  <span class="nb">globals</span><span class="p">()[</span><span class="n">ep</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ep</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
  <span class="k">del</span> <span class="n">ep</span>
<span class="k">del</span> <span class="n">pkg_resources</span>

<span class="c1"># Formats included when doing &quot;from pygeode.formats import *&quot;</span>
<span class="c1"># Note: additional formats from the plugin directories are added dynamically</span>
<span class="c1"># (see pygeode/__init__.py)</span>

<span class="kn">from</span> <span class="nn">.multifile</span> <span class="kn">import</span> <span class="n">openall</span><span class="p">,</span> <span class="n">open_multi</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;openall&#39;</span><span class="p">,</span> <span class="s1">&#39;open_multi&#39;</span><span class="p">,</span> <span class="s1">&#39;open&#39;</span><span class="p">,</span> <span class="s1">&#39;save&#39;</span><span class="p">]</span>

<span class="n">extdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;.nc&#39;</span><span class="p">:</span><span class="s1">&#39;netcdf4&#39;</span><span class="p">,</span>
           <span class="s1">&#39;.hdf&#39;</span><span class="p">:</span> <span class="s1">&#39;hdf4&#39;</span><span class="p">,</span>
           <span class="s1">&#39;.grib&#39;</span><span class="p">:</span><span class="s1">&#39;grib&#39;</span> <span class="p">}</span>

<span class="kn">from</span> <span class="nn">pygeode.var</span> <span class="kn">import</span> <span class="n">Var</span>
<span class="k">class</span> <span class="nc">PackVar</span><span class="p">(</span><span class="n">Var</span><span class="p">):</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
  <span class="c1"># {{{</span>
    <span class="kn">from</span> <span class="nn">pygeode.var</span> <span class="kn">import</span> <span class="n">copy_meta</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">var</span>

    <span class="c1"># At present data is packed into short integers following the packing</span>
    <span class="c1"># algorithm described in the NetCDF Operator documentation</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span>

    <span class="nb">min</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">nanmin</span><span class="p">()</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">nanmax</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">16</span> <span class="o">-</span> <span class="mf">2.</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">min</span> <span class="o">+</span> <span class="nb">max</span><span class="p">)</span>

    <span class="n">Var</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">copy_meta</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">atts</span><span class="p">[</span><span class="s1">&#39;packing_convention&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;NetCDF (16 bit)&#39;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">atts</span><span class="p">[</span><span class="s1">&#39;scale_factor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">atts</span><span class="p">[</span><span class="s1">&#39;add_offset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span>
  <span class="c1"># }}}</span>

  <span class="k">def</span> <span class="nf">getview</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">pbar</span><span class="p">):</span>
  <span class="c1"># {{{</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">view</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="n">pbar</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="c1"># }}}</span>

<div class="viewcode-block" id="autodetectformat"><a class="viewcode-back" href="../../fileio.html#pygeode.autodetectformat">[docs]</a><span class="k">def</span> <span class="nf">autodetectformat</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="c1"># {{{</span>
  <span class="sd">&#39;&#39;&#39; Returns best guess at file format based on file name.</span>

<span class="sd">      Parameters</span>
<span class="sd">      ==========</span>
<span class="sd">      filename : string</span>
<span class="sd">        Filename to identify</span>

<span class="sd">      Returns</span>
<span class="sd">      =======</span>
<span class="sd">      string</span>
<span class="sd">        String specifying identified file format.   </span>

<span class="sd">      Raises</span>
<span class="sd">      ======</span>
<span class="sd">      ValueError</span>
<span class="sd">        If the format cannot be determined from the extension.</span>

<span class="sd">      See Also</span>
<span class="sd">      ========</span>
<span class="sd">      extdict</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">path</span>

  <span class="n">rt</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
  <span class="nb">format</span> <span class="o">=</span> <span class="n">extdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ext</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unrecognized extension &quot;</span><span class="si">%s</span><span class="s1">&quot;; please specify a file format.&#39;</span> <span class="o">%</span> <span class="n">ext</span><span class="p">)</span>

  <span class="k">return</span> <span class="nb">format</span></div>
<span class="c1"># }}}</span>

<div class="viewcode-block" id="open"><a class="viewcode-back" href="../../fileio.html#pygeode.open">[docs]</a><span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">format</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">value_override</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">dimtypes</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">namemap</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">varlist</span> <span class="o">=</span> <span class="p">[],</span>
         <span class="n">cfmeta</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="c1"># {{{</span>
  <span class="sd">&#39;&#39;&#39; Returns a :class:`Dataset` containing variables defined in a single file or a dict of :class:`Dataset`</span>
<span class="sd">  for a netcdf4 file containing groups.</span>

<span class="sd">  Parameters</span>
<span class="sd">  ==========</span>
<span class="sd">  filename : string</span>
<span class="sd">    Path of file to open</span>

<span class="sd">  format : string, optional</span>
<span class="sd">    String specifying format of file to open. If none is given the format will be automatically</span>
<span class="sd">    detected from the file (see :func:`autodetectformat`)</span>

<span class="sd">  value_override : dict, optional</span>
<span class="sd">    A dictionary containing arrays with which to override values for one or more variables (specified</span>
<span class="sd">    by the keys). This can be used for instance to avoid loading the values of an axis whose values</span>
<span class="sd">    are severely scattered across a large file.</span>

<span class="sd">  dimtypes : dict, optional</span>
<span class="sd">    A dictionary mapping dimension names to axis classes. The keys should be</span>
<span class="sd">    axis names as defined in the file; values should be one of:</span>

<span class="sd">    1. an axis instance, which will be used directly</span>
<span class="sd">    2. an axis class, which will be used to create a new instance with the values given by the file</span>
<span class="sd">    3. a tuple of an axis class and a dictionary with keyword arguments to pass to that axis&#39; constructor              </span>

<span class="sd">    If dimtypes is not specified, an attempt is made to automatically identify the axis types (see optional</span>
<span class="sd">    `cfmeta` argument below)</span>

<span class="sd">  namemap : dict, optional</span>
<span class="sd">    A dictionary to map variable names as specified in the file (keys) to PyGeode variable names</span>
<span class="sd">    (values); also works for axes/dimensions</span>

<span class="sd">  varlist : list, optional</span>
<span class="sd">    A list (of strings) specifying the variables that should be loaded into the</span>
<span class="sd">    data set (if the list is empty, all NetCDF variables will be loaded)</span>

<span class="sd">  cfmeta : boolean</span>
<span class="sd">    If true, an attempt to identify the type of each dimension is made</span>
<span class="sd">    following the CF metadata conventions.</span>

<span class="sd">  Returns</span>
<span class="sd">  =======</span>
<span class="sd">  dataset</span>
<span class="sd">    A dataset containing the variables contained in the file or a dict of datasets. The variable data itself is not loaded</span>
<span class="sd">    into memory. </span>

<span class="sd">  Notes</span>
<span class="sd">  =====</span>
<span class="sd">  The format of the file is automatically detected from the filename (if</span>
<span class="sd">  possible); otherwise it must be specified by the ``format`` argument. </span>
<span class="sd">  The identifiers used in ``varlist`` and ``dimtypes`` are the original names used in</span>
<span class="sd">  the NetCDF file, not the names given in ``namemap``.</span>
<span class="sd">  The optional arguments are not currently supported for netcdf4 files containing groups.</span>

<span class="sd">  See Also</span>
<span class="sd">  ========</span>
<span class="sd">  openall</span>
<span class="sd">  open_multi</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="nb">format</span> <span class="o">=</span> <span class="n">autodetectformat</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="s1">&#39;open&#39;</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="nb">format</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s2">&quot;pygeode.formats.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">format</span><span class="p">,</span> <span class="n">fromlist</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;pygeode.formats&quot;</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unrecognized format module </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="nb">format</span><span class="p">)</span>

  <span class="k">return</span> <span class="nb">format</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">value_override</span><span class="o">=</span><span class="n">value_override</span><span class="p">,</span> <span class="n">dimtypes</span><span class="o">=</span><span class="n">dimtypes</span><span class="p">,</span> \
              <span class="n">namemap</span><span class="o">=</span><span class="n">namemap</span><span class="p">,</span> <span class="n">varlist</span><span class="o">=</span><span class="n">varlist</span><span class="p">,</span> <span class="n">cfmeta</span><span class="o">=</span><span class="n">cfmeta</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
<span class="c1"># }}}</span>

<div class="viewcode-block" id="save"><a class="viewcode-back" href="../../fileio.html#pygeode.save">[docs]</a><span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cfmeta</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="c1"># {{{</span>
  <span class="sd">&#39;&#39;&#39; Saves a :class:`Var` or :class:`Dataset` to file.</span>

<span class="sd">  Parameters</span>
<span class="sd">  ==========</span>
<span class="sd">  filename : string</span>
<span class="sd">    Path of file to save to.</span>

<span class="sd">  dataset : :class:`Var`, :class:`Dataset`, or collection of :class:`Var` objects or </span>
<span class="sd">    dict of :class:`Dataset` objects.</span>
<span class="sd">    The dataset is consolidated using :func:`dataset.asdataset`. Dicts of `Dataset` objects</span>
<span class="sd">    are written as groups to netcdf4 files.</span>

<span class="sd">  format : string, optional</span>
<span class="sd">    String specifying format of file to open. If none is given the format will be automatically</span>
<span class="sd">    detected from the file (see :func:`autodetectformat`)</span>

<span class="sd">  cfmeta : boolean</span>
<span class="sd">    If true, metadata is automatically written specifying the axis dimensions following CF</span>
<span class="sd">    metadata conventions.</span>

<span class="sd">  Notes</span>
<span class="sd">  =====</span>
<span class="sd">  The format of the file is automatically detected from the filename (if</span>
<span class="sd">  possible). The NetCDF format is at present the best supported.</span>
<span class="sd">  &#39;&#39;&#39;</span>
  <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="nb">format</span> <span class="o">=</span> <span class="n">autodetectformat</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="s1">&#39;save&#39;</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="nb">format</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s2">&quot;pygeode.formats.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">format</span><span class="p">,</span> <span class="n">fromlist</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;pygeode.formats&quot;</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unrecognized format module </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="nb">format</span><span class="p">)</span>

  <span class="nb">format</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">cfmeta</span><span class="o">=</span><span class="n">cfmeta</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
<span class="c1"># }}}</span>

<span class="c1"># Coerce axes into particular types</span>
<span class="c1"># (useful if there&#39;s no existing ruleset for detecting your axes)</span>
<span class="c1"># (based on deprecated tools.make_axis)</span>
<span class="k">def</span> <span class="nf">set_axistypes</span> <span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">dimtypes</span><span class="p">):</span>
<span class="c1"># {{{</span>
  <span class="kn">from</span> <span class="nn">pygeode.axis</span> <span class="kn">import</span> <span class="n">Axis</span>
  <span class="kn">from</span> <span class="nn">pygeode.var</span> <span class="kn">import</span> <span class="n">copy_meta</span>
  <span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">FunctionType</span>
  <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimtypes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>

  <span class="n">replacements</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="k">for</span> <span class="n">oldaxis</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">oldaxis</span><span class="o">.</span><span class="n">name</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dimtypes</span><span class="p">:</span> <span class="k">continue</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dimtypes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="c1"># Determine axis type      </span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">Axis</span><span class="p">):</span>   <span class="c1"># Axis instance</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">oldaxis</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided axis instance </span><span class="si">%s</span><span class="s1"> is the wrong length (expected length </span><span class="si">%d</span><span class="s1">, got length </span><span class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">dt</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">oldaxis</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
      <span class="n">axis</span> <span class="o">=</span> <span class="n">dt</span> 
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="s1">&#39;__bases__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">Axis</span><span class="p">):</span> <span class="c1"># Axis class</span>
      <span class="n">dimclass</span> <span class="o">=</span> <span class="n">dt</span>
      <span class="n">axis</span> <span class="o">=</span> <span class="n">dimclass</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="n">oldaxis</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
      <span class="c1"># Copy the file metadata (but discard plot attributes from the old axis)</span>
      <span class="c1"># (See issue 22)</span>
      <span class="n">copy_meta</span> <span class="p">(</span><span class="n">oldaxis</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">plotatts</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Got a list/tuple for dimtypes, but did not have 2 elements as expected (Axis class, parameters).  Instead, got </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="o">%</span><span class="n">dt</span><span class="p">)</span>
      <span class="n">dimclass</span><span class="p">,</span> <span class="n">dimargs</span> <span class="o">=</span> <span class="n">dt</span>
      <span class="n">dimargs</span> <span class="o">=</span> <span class="n">dimargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
      <span class="k">assert</span> <span class="nb">issubclass</span> <span class="p">(</span><span class="n">dimclass</span><span class="p">,</span> <span class="n">Axis</span><span class="p">),</span> <span class="s2">&quot;expected an Axis subclass, got </span><span class="si">%s</span><span class="s2"> instead.&quot;</span><span class="o">%</span><span class="n">dimclass</span>
      <span class="k">assert</span> <span class="nb">isinstance</span> <span class="p">(</span><span class="n">dimargs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
      <span class="k">if</span> <span class="s1">&#39;values&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dimargs</span><span class="p">:</span>  <span class="n">dimargs</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldaxis</span><span class="o">.</span><span class="n">values</span>
      <span class="n">axis</span> <span class="o">=</span> <span class="n">dimclass</span><span class="p">(</span><span class="o">**</span><span class="n">dimargs</span><span class="p">)</span>
    <span class="c1"># Axis-creating function?</span>
    <span class="k">elif</span> <span class="nb">isinstance</span> <span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">FunctionType</span><span class="p">):</span>
      <span class="n">axis</span> <span class="o">=</span> <span class="n">dt</span><span class="p">(</span><span class="n">oldaxis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unrecognized dimtypes parameter. Expected a dictionary, axis class, or axis instance.  Got </span><span class="si">%s</span><span class="s1"> instead.&#39;</span><span class="o">%</span><span class="nb">type</span><span class="p">(</span><span class="n">dt</span><span class="p">))</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">oldaxis</span><span class="p">),</span> <span class="s2">&quot;expected axis of length </span><span class="si">%s</span><span class="s2">, ended up with axis of length </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">oldaxis</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
    <span class="n">replacements</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis</span>

  <span class="k">return</span> <span class="n">dataset</span><span class="o">.</span><span class="n">replace_axes</span><span class="p">(</span><span class="n">axisdict</span><span class="o">=</span><span class="n">replacements</span><span class="p">)</span>
<span class="c1"># }}}</span>

<span class="c1"># Apply variable whitelist to a dataset (only keep specific variables)</span>
<span class="k">def</span> <span class="nf">whitelist</span> <span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">varlist</span><span class="p">):</span>
<span class="c1"># {{{</span>
  <span class="kn">from</span> <span class="nn">pygeode.dataset</span> <span class="kn">import</span> <span class="n">Dataset</span>
  <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">varlist</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">))</span>
  <span class="nb">vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">dataset</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">varlist</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">vardict</span><span class="p">]</span>
  <span class="n">dataset</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="n">atts</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">atts</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">dataset</span>
<span class="c1"># }}}</span>

<span class="k">def</span> <span class="nf">finalize_open</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">dimtypes</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">namemap</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">varlist</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">cfmeta</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="c1"># {{{</span>
  <span class="kn">from</span> <span class="nn">pygeode.formats</span> <span class="kn">import</span> <span class="n">cfmeta</span> <span class="k">as</span> <span class="n">cf</span>
  <span class="c1"># Process CF-metadata?</span>
  <span class="k">if</span> <span class="n">cfmeta</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
    <span class="c1"># Skip anything that we&#39;re going to override in dimtypes</span>
    <span class="c1"># (so we don&#39;t get any meaningless warnings or other crap from cfmeta)</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">decode_cf</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">dimtypes</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

  <span class="c1"># Apply custom axis types?</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimtypes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">set_axistypes</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">dimtypes</span><span class="p">)</span>

  <span class="c1"># Keep only specific variables?</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">varlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">whitelist</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">varlist</span><span class="p">)</span>

  <span class="c1"># Rename variables?</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">namemap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># Check both axes and variables</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">rename_vars</span><span class="p">(</span><span class="n">vardict</span><span class="o">=</span><span class="n">namemap</span><span class="p">)</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">rename_axes</span><span class="p">(</span><span class="n">axisdict</span><span class="o">=</span><span class="n">namemap</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">dataset</span>
<span class="c1"># }}}</span>

<span class="k">def</span> <span class="nf">finalize_save</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">cfmeta</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">pack</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="c1"># {{{</span>
  <span class="kn">from</span> <span class="nn">pygeode.formats</span> <span class="kn">import</span> <span class="n">cfmeta</span> <span class="k">as</span> <span class="n">cf</span>
  <span class="kn">from</span> <span class="nn">pygeode.dataset</span> <span class="kn">import</span> <span class="n">asdataset</span>

  <span class="c1"># Only pack if pack is true</span>
  <span class="k">if</span> <span class="n">pack</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pack</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span> <span class="c1"># Assume this is a list of variables to pack</span>
      <span class="nb">vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">PackVar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">pack</span> <span class="k">else</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">vars</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="nb">vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">PackVar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">vars</span><span class="p">]</span>
    <span class="n">dset</span> <span class="o">=</span> <span class="n">asdataset</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>
    <span class="n">dset</span><span class="o">.</span><span class="n">atts</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">atts</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">dset</span> <span class="o">=</span> <span class="n">dataset</span>

  <span class="c1"># Encode standard axes back into netcdf metadata?</span>
  <span class="k">if</span> <span class="n">cfmeta</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">cf</span><span class="o">.</span><span class="n">encode_cf</span><span class="p">(</span><span class="n">dset</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">asdataset</span><span class="p">(</span><span class="n">dset</span><span class="p">)</span>
<span class="c1"># }}}</span>

</pre></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="../../reference.html">Reference</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../tutorial.html">Tutorial</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../gallery/index.html">Gallery</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Mike Neish, Peter Hitchcock.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>